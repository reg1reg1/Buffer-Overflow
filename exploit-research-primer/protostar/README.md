# Prostar challenges
This section documents the work done on solving the prostar challenges which can be found here [Link]().
The Prostar VM is a debian based Linux OS and all the executables are in 32-bit ELF format.

Our initial angle would be try to solve the challenges without looking/referring the source code, which would add the challenge of
reversing to the mix. For debugging the crackmes (dynamic/runtime) , I have used EDB or evan's debugger. For the static analysis , I will attempt to use GHIDRA. I have some prior experience with GDB, IDA and ImmunityDBG , which came handy during these excercises.


## Stack0

The edb is used to run it. We see that the jmp is dictated by the Zero flag. JE command performs a JMP when the Zero flag is set. We see that a command "test eax,eax" is used. The test eax is a bitwise AND operation. Note that 'test' sets the zero flag, when the result of the and opertaion is zero, i.e the case when both the operands are zero. test eax,eax will set the zero flag, only when eax is zero. 

So, we have to make sure eax is anything but zero to prevent the JMP. The eax is loaded with a value from the stack. 0x5c is the offset. Using buffer overflow we can overwrite this, and achieve the target intended.


## Stack1

In this instead of any arbitary value other than zero, we have to fill the variable using a target value. From the assembly code we see that a 'cmp' is being performed which determines the outcome of the program.
Now, what we need to do is calculate the offset of the overflow. This can be done by using a pattern generator which may be found natively with metasploit implementations, or can be found online.

We find that the offset of the overwritten value is 64. The value being compared is hex \x61\x62\x63\x64. Note that the stack is filled in the direction opposite to buffer growth. Stack grows from high memory to low memory, and the buffer (& heap) grow from low memory to high memory.


## Stack2
This is a similar 
