# Protostar challenges
This section documents the work done on solving the prostar challenges which can be found here [Link]().
The Prostar VM is a debian based Linux OS and all the executables are in 32-bit ELF format.

Our initial angle would be try to solve the challenges without looking/referring the source code/hints, which would add the challenge of
reversing to the mix. I have downloaded the crackmes from the protostar VM onto my Kali distro with tools of my choice.

For debugging the crackmes (dynamic/runtime) , I have used EDB or evan's debugger. For the static analysis , I will attempt to use GHIDRA. I have some prior experience with GDB, IDA and ImmunityDBG , which came handy during these excercises.


## Stack0

The edb is used to run it. We see that the jmp is dictated by the Zero flag. JE command performs a JMP when the Zero flag is set. We see that a command "test eax,eax" is used. The test eax is a bitwise AND operation. Note that 'test' sets the zero flag, when the result of the and opertaion is zero, i.e the case when both the operands are zero. test eax,eax will set the zero flag, only when eax is zero. 

So, we have to make sure eax is anything but zero to prevent the JMP. The eax is loaded with a value from the stack. 0x5c is the offset. Using buffer overflow we can overwrite this, and achieve the target intended.


## Stack1

In this instead of any arbitary value other than zero, we have to fill the variable using a target value. From the assembly code we see that a 'cmp' is being performed which determines the outcome of the program.
Now, what we need to do is calculate the offset of the overflow. This can be done by using a pattern generator which may be found natively with metasploit implementations, or can be found online.

We find that the offset of the overwritten value is 64. The value being compared is hex \x61\x62\x63\x64. Note that the stack is filled in the direction opposite to buffer growth. Stack grows from high memory to low memory, and the buffer (& heap) grow from low memory to high memory.


## Stack2
This is a similar challenge to Stack1. The point of overflow here is the environment variable. This is the point of entry for the overflow.
We know from the debugger output, that an environment variable called "GREENIE" is being used from the EDB debugger which prints the ASCII strings on screen.
Note that GREENIE needs to cause a buffer overflow, which happens during the vulnerable strcpy function. The value in the EAX register is being compared to 'd0a0d0a' in hex. Again, like in stack1 we need to push a string which offsets at 64. So the value being overwritten is at an exact distance from the start of the string.
```python
export GREENIE=$(python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0a\x0d\x0a\x0d'")
```
Now the next thing would be to run the program, which will give us the desired output.


## Stack3
The function in main checks a value which I replaced in Ghidra to the name 'switchF' and 'targetInput' is the one we need to overflow. We can see from the disassembled code clearly what is happening without having to read much assembly code. We see that the switchF needs to change, for our function to enter the if condition. The jump however needs to happen to a different function for us to win this challenge. There is only 1 non-c non-library function as Ghidra points out which is 'win'. We need to store this address value on the switchF, for us to successfully execute this function and win the challenge.
We can see from the images the offset address we need to overwrite. 

We can see that once we do this and overwrite using the offset we are able to overwrite the variable with success. It should be noted that function local variables are stored in the stack in the order they are declared. Note that we can overwrite the 'switchF' as it is declared after the 'targetInput' variable. So targetInput goes in the stack first, followed by the switchF. When the buffer overflows, the overflow is written onto the next variable stored in the stack. Always remember the layout of the function frame including the EBP and the RET address values when performing an overflow.


## Stack4 
Vanilla Buffer overflow. Here we overwrite the return address.
```python
python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xf4\x83\x04\x08'" | ./stack4
```


## Stack5

In this challenge, we need to perform a buffer overflow and spawn a shell. Basically, our payload here is a shellcode. I will use the standard JMP-CALL-POP shellcode which I wrote, and which can be found here [Link](). As any standard exploit we need to overwrite the return address and make it point to our shellcode. Just for being fancy, I will be using a xor Encoded shellcode which I wrote. This shellcode is 68 bytes long which means we need to pad the next 8 bytes and more to cause the overflow




## Stack6
