# Protostar challenges
This section documents the work done on solving the prostar challenges which can be found here [Link]().
The Prostar VM is a debian based Linux OS and all the executables are in 32-bit ELF format.

Our initial angle would be try to solve the challenges without looking/referring the source code/hints, which would add the challenge of
reversing to the mix. I have downloaded the crackmes from the protostar VM onto my Kali distro with tools of my choice.

For debugging the crackmes (dynamic/runtime) , I have used EDB or evan's debugger. For the static analysis , I will attempt to use GHIDRA. I have some prior experience with GDB, IDA and ImmunityDBG , which came handy during these excercises. ASLR was disabled for all the challenges in this section.



We have different ways and methods of designing and writing exploits. The ret2libc and vanilla overwrite are 2 of the most common design techniques used for the exploits in this exercise. Look at the code for comments in case something is not clear.

| ![intro.png](images/intro.png) |
| :----------------------------: |
|        Exploit designs         |

## Stack-based

### Stack0

The edb is used to run it. We see that the jmp operation is dictated by the Zero flag. JE command performs a JMP when the Zero flag is set. We see that a command "test eax,eax" is used. The test eax is a **bitwise AND** operation. Note that 'test' sets the zero flag, when the result of the and opertaion is zero, i.e the case when both the operands are zero. test eax,eax will set the zero flag, only when eax is zero. 

So, we have to make sure eax is anything but zero to prevent the JMP. The eax is loaded with a value from the stack. 0x5c is the offset. Using buffer overflow we can overwrite this, and achieve the target intended.

|              ![stack0.PNG](images/stack0.PNG)              |
| :--------------------------------------------------------: |
| EAX register needs to be overwritten with a non-zero value |


### Stack1

In this instead of any arbitary value other than zero, we have to fill the variable using a target value. From the assembly code we see that a '**cmp'** is being performed which determines the outcome of the program.
What we need to do now ,is to calculate the offset of the overflow. This can be done by using a pattern generator which may be found natively with metasploit implementations, or can be found online. This offset is the distance between the start of our payload and the eip overloaded value in bytes. The offset calculation is a recurring concept in initial exploit design.

We find that the offset of the overwritten value is 64. The value being compared is hex \x61\x62\x63\x64. Note that the stack is filled in the direction opposite to buffer growth. Stack grows from high memory to low memory, and the buffer (& heap) grow from low memory to high memory.

|               ![stack1.PNG](images/stack1.PNG)               |
| :----------------------------------------------------------: |
| Overwrite the eax with a constant value to alter program flow |


### Stack2
This is a similar challenge to Stack1. The point of overflow here is the environment variable. This is the point of entry for the overflow.
We know from the debugger output, that an environment variable called "GREENIE" is being used from the EDB debugger which prints the ASCII strings on screen.
Note that GREENIE needs to cause a buffer overflow, which happens during the vulnerable strcpy function. The value in the EAX register is being compared to 'd0a0d0a' in hex. Again, like in stack1 we need to push a string which offsets at 64. So the value being overwritten is at an exact distance from the start of the string, and we prefill the value with 64 leading A's , and you can do it in any manner except taking care not to include bad characters.

```python
export GREENIE=$(python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0a\x0d\x0a\x0d'")
```
Now the next thing would be to run the program, which will give us the desired output.  

|       ![stack2.PNG](images/offset_stack2.PNG)       |
| :-------------------------------------------------: |
| Altering the environment variable to cause overflow |


### Stack3
The function in main checks a value which I replaced in **Ghidra** to the name 'switchF' and 'targetInput' is the one we need to overflow. We can see from the disassembled code clearly what is happening without having to read much assembly code. We see that the switchF needs to change, for our function to enter the if condition. The jump however needs to happen to a different function for us to win this challenge. There is only 1 non-c non-library function as Ghidra points out which is 'win'. We need to store this address value on the switchF, for us to successfully execute this function and win the challenge.
We can see from the images the offset address we need to overwrite. 

We can see that once we do this and overwrite using the offset we are able to overwrite the variable with success. It should be noted that function local variables are stored in the stack in the order they are declared. Note that we can overwrite the 'switchF' as it is declared after the 'targetInput' variable. So targetInput goes in the stack first, followed by the switchF. When the buffer overflows, the overflow is written onto the next variable stored in the stack. Always remember the layout of the function frame including the EBP and the RET address values when performing an overflow. The functions in the absence of ASLR are loaded at a fixed offset from a fixed starting address space.

|   ![stack3.PNG](images/stack3.PNG)    |
| :-----------------------------------: |
| Looking at the disassembled functions |

|            ![stack3win.PNG](images/stack3win.PNG)            |
| :----------------------------------------------------------: |
| The variable 'switchF' is in our control because of overflow of 'targetInput' |

### Stack4 

Vanilla Buffer overflow. Here we overwrite the return address, like covered in several exploit research exercises before. The steps are to calculate the offset, and supply the exploit via command-line arguments to the exploit as shown below.
```python
python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xf4\x83\x04\x08'" | ./stack4
```

|              ![rootwe-0.PNG](images/stack4.PNG)              |
| :----------------------------------------------------------: |
| A vanilla buffer overflow exploit, controlling the EIP to point to our desired function |

### Stack5

In this challenge, we need to perform a buffer overflow and spawn a shell. Basically, our payload here is a shellcode, and we can write our own or use an existing shellcode. As any standard exploit we need to overwrite the return address and make it point to our shellcode. You can write your own shellcode here, and complete the challenge. This challenge , even though I have executed several buffer overflows for countless similar c programs threw me off. The source code is as simple as it can get. I figure here that because of certain headers being included, this behaves like this. The shellcode runs into an error where it shows "ILLEGAL Instruction" for quite a while, before I had to go with a different exploit design.

My initial exploit was 
```bash
::NOPSLED::SHELLCODE::PADDING::EIP:: 
```

Here the EIP points back to the shellcode. Due to being present in lower memory address, the shellcode was showing ILLEGAL instruction. As of writing this , I am still trying to figure out why this exploit design failed. Next, I tried a different exploit design suggested by the famous ["LiveOverflow"](https://liveoverflow.com/) in his videos, and added a NOPSLED size of 400 to place the shellcode lower in stack (higher memory).

```bash
::PADDING::EIP::HUGE-NOPSLED::SHELLCODE
```
This worked after piping an extra character via cat. The shellcode like others have been tested to work on Ubuntu16.04. This is because the bin/bash shell being called from the unistd.h header was expecting a character. This is highlighted by **liveoverflow** in his description of the exploit solution.

The exploit is piped to STDOUT and in the file stack5.py. To pipe it from within gdb(make sure the executable is loaded):
```bash
run < <(./stack5.py)
```

From outside gdb, we need to pipe the extra char.

```bash
(./stack5.py;cat) | ./crackmes/stack5
```

|  ![rootwe-0.PNG](images/stack5overwrite.PNG)   |
| :--------------------------------------------: |
| The overwrite using the payload is successful. |





### Stack6

This challenge is a curve ball, even though the underlying technique of exploitation is well known. The binary here prevents us to overwrite the return address with some specific prefix. The check is put on the stack for preventing us using the vanilla exploit methods. Here we will use a technique which we used in the exploit-research for Win32 systems which is known as 'return-to-libc'. This is often used to bypass 'exec' protections on stack. There are several variations to this method 
such as the 'libc chaining' method which is explained by 'Phrack' in this article [here](http://phrack.org/issues/58/4.html). The libc method exploits the control of the stack, and its layout specifically. In a restriction on stack execution, the shellcode may not reside on the stack. The technique return-to-libc lays out the stack after an overflow as shown by the following image.

"Insert image here"

We find a systemcall in the libc in the executable library. Instead of EIP pointing to a shellcode, EIP would now point to this address. In a function layout , a function's instruction pointer usually points to the EBP (before the instruction for carving out space for local variables is hit) as shown in the image. The next (higher in memory, lower in stack) value is the return address of the next function. Here we can point to exit() so that the process exits. We would spawn a separate process on execve execution. The next instruction would be the function argument for the current function. This for a systemcall would be the address of the command string being called. In this case, this must be the address of the string "/bin/bash". There are several methods to locate this string in the executable using the 'strings' utility. On GUI debuggers such as the EDB this is trivial.

Locating system call within the libc and having executable privileges is easy on EDB, and on GDB , one may simply do the following to find out the location of the systemcall as shown from within gdb. You may use other utilities such as mselfscan (a metasploit utility) or using the 'strings'utility. 

Note that the libc syscall takes only 1 argument which is the string address of the function being called. The stack6.py was used to generate the payload which was tested on the executable running on a 16.04 Ubuntu system.

|              ![rootwe-0.PNG](images/stack6.PNG)              |
| :----------------------------------------------------------: |
| Locating a syscall for performing ret2libc in the desired address range in EDB |

### Stack 7

This challenge again, reimposes a restriction on the blatant overriding of return address. Here we will employ a technique called "return to .text"



