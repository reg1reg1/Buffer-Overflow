# Protostar challenges
This section documents the work done on solving the prostar challenges which can be found here [Link]().
The Prostar VM is a debian based Linux OS and all the executables are in 32-bit ELF format.

Our initial angle would be try to solve the challenges without looking/referring the source code/hints, which would add the challenge of
reversing to the mix. I have downloaded the crackmes from the protostar VM onto my Kali distro with tools of my choice.

For debugging the crackmes (dynamic/runtime) , I have used EDB or evan's debugger. For the static analysis , I will attempt to use GHIDRA. I have some prior experience with GDB, IDA and ImmunityDBG , which came handy during these excercises. ASLR was disabled for all the challenges in this section.



We have different ways and methods of designing and writing exploits. The ret2libc and vanilla overwrite are 2 of the most common design techniques used for the exploits in this exercise. Look at the code for comments in case something is not clear.

| ![intro.png](images/intro.png) |
| :----------------------------: |
|        Exploit designs         |

## Stack-based

### Stack0

The edb is used to run it. We see that the jmp operation is dictated by the Zero flag. JE command performs a JMP when the Zero flag is set. We see that a command "test eax,eax" is used. The test eax is a **bitwise AND** operation. Note that 'test' sets the zero flag, when the result of the and opertaion is zero, i.e the case when both the operands are zero. test eax,eax will set the zero flag, only when eax is zero. 

So, we have to make sure eax is anything but zero to prevent the JMP. The eax is loaded with a value from the stack. 0x5c is the offset. Using buffer overflow we can overwrite this, and achieve the target intended.

|              ![stack0.PNG](images/stack0.PNG)              |
| :--------------------------------------------------------: |
| EAX register needs to be overwritten with a non-zero value |


### Stack1

In this instead of any arbitary value other than zero, we have to fill the variable using a target value. From the assembly code we see that a '**cmp'** is being performed which determines the outcome of the program.
What we need to do now ,is to calculate the offset of the overflow. This can be done by using a pattern generator which may be found natively with metasploit implementations, or can be found online. This offset is the distance between the start of our payload and the eip overloaded value in bytes. The offset calculation is a recurring concept in initial exploit design.

We find that the offset of the overwritten value is 64. The value being compared is hex \x61\x62\x63\x64. Note that the stack is filled in the direction opposite to buffer growth. Stack grows from high memory to low memory, and the buffer (& heap) grow from low memory to high memory.

|               ![stack1.PNG](images/stack1.PNG)               |
| :----------------------------------------------------------: |
| Overwrite the eax with a constant value to alter program flow |


### Stack2
This is a similar challenge to Stack1. The point of overflow here is the environment variable. This is the point of entry for the overflow.
We know from the debugger output, that an environment variable called "GREENIE" is being used from the EDB debugger which prints the ASCII strings on screen.
Note that GREENIE needs to cause a buffer overflow, which happens during the vulnerable strcpy function. The value in the EAX register is being compared to 'd0a0d0a' in hex. Again, like in stack1 we need to push a string which offsets at 64. So the value being overwritten is at an exact distance from the start of the string, and we prefill the value with 64 leading A's , and you can do it in any manner except taking care not to include bad characters.

```python
export GREENIE=$(python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0a\x0d\x0a\x0d'")
```
Now the next thing would be to run the program, which will give us the desired output.  

|       ![stack2.PNG](images/offset_stack2.PNG)       |
| :-------------------------------------------------: |
| Altering the environment variable to cause overflow |


### Stack3
The function in main checks a value which I replaced in **Ghidra** to the name 'switchF' and 'targetInput' is the one we need to overflow. We can see from the disassembled code clearly what is happening without having to read much assembly code. We see that the switchF needs to change, for our function to enter the if condition. The jump however needs to happen to a different function for us to win this challenge. There is only 1 non-c non-library function as Ghidra points out which is 'win'. We need to store this address value on the switchF, for us to successfully execute this function and win the challenge.
We can see from the images the offset address we need to overwrite. 

We can see that once we do this and overwrite using the offset we are able to overwrite the variable with success. It should be noted that function local variables are stored in the stack in the order they are declared. Note that we can overwrite the 'switchF' as it is declared after the 'targetInput' variable. So targetInput goes in the stack first, followed by the switchF. When the buffer overflows, the overflow is written onto the next variable stored in the stack. Always remember the layout of the function frame including the EBP and the RET address values when performing an overflow. The functions in the absence of ASLR are loaded at a fixed offset from a fixed starting address space.

|   ![stack3.PNG](images/stack3.PNG)    |
| :-----------------------------------: |
| Looking at the disassembled functions |

|            ![stack3win.PNG](images/stack3win.PNG)            |
| :----------------------------------------------------------: |
| The variable 'switchF' is in our control because of overflow of 'targetInput' |

### Stack4 

Vanilla Buffer overflow. Here we overwrite the return address, like covered in several exploit research exercises before. The steps are to calculate the offset, and supply the exploit via command-line arguments to the exploit as shown below.
```python
python -c "print 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xf4\x83\x04\x08'" | ./stack4
```

|              ![rootwe-0.PNG](images/stack4.PNG)              |
| :----------------------------------------------------------: |
| A vanilla buffer overflow exploit, controlling the EIP to point to our desired function |

### Stack5

In this challenge, we need to perform a buffer overflow and spawn a shell. Basically, our payload here is a shellcode, and we can write our own or use an existing shellcode. As any standard exploit we need to overwrite the return address and make it point to our shellcode. You can write your own shellcode here, and complete the challenge. This challenge , even though I have executed several buffer overflows for countless similar c programs threw me off. The source code is as simple as it can get. I figure here that because of certain headers being included, this behaves like this. The shellcode runs into an error where it shows "ILLEGAL Instruction" for quite a while, before I had to go with a different exploit design.

My initial exploit was 
```bash
::NOPSLED::SHELLCODE::PADDING::EIP:: 
```

Here the EIP points back to the shellcode. Due to being present in lower memory address, the shellcode was showing ILLEGAL instruction. As of writing this , I am still trying to figure out why this exploit design failed. Next, I tried a different exploit design suggested by the famous ["LiveOverflow"](https://liveoverflow.com/) in his videos, and added a NOPSLED size of 400 to place the shellcode lower in stack (higher memory).

```bash
::PADDING::EIP::HUGE-NOPSLED::SHELLCODE
```
This worked after piping an extra character via cat. The shellcode like others have been tested to work on Ubuntu16.04. This is because the bin/bash shell being called from the unistd.h header was expecting a character. This is highlighted by **liveoverflow** in his description of the exploit solution.

The exploit is piped to STDOUT and in the file stack5.py. To pipe it from within gdb(make sure the executable is loaded):
```bash
run < <(./stack5.py)
```

From outside gdb, we need to pipe the extra char.

```bash
(./stack5.py;cat) | ./crackmes/stack5
```

|  ![rootwe-0.PNG](images/stack5overwrite.PNG)   |
| :--------------------------------------------: |
| The overwrite using the payload is successful. |





### Stack6

This challenge is a curve ball, even though the underlying technique of exploitation is well known. The binary here prevents us to overwrite the return address with some specific prefix. The check is put on the stack for preventing us using the vanilla exploit methods. Here we will use a technique which we used in the exploit-research for Win32 systems which is known as 'return-to-libc'. This is often used to bypass 'exec' protections on stack. There are several variations to this method 
such as the 'libc chaining' method which is explained by 'Phrack' in this article [here](http://phrack.org/issues/58/4.html). The libc method exploits the control of the stack, and its layout specifically. In a restriction on stack execution, the shellcode may not reside on the stack. The technique return-to-libc lays out the stack after an overflow as shown by the following image.

"Insert image here"

We find a systemcall in the libc in the executable library. Instead of EIP pointing to a shellcode, EIP would now point to this address. In a function layout , a function's instruction pointer usually points to the EBP (before the instruction for carving out space for local variables is hit) as shown in the image. The next (higher in memory, lower in stack) value is the return address of the next function. Here we can point to exit() so that the process exits. We would spawn a separate process on execve execution. 

The next instruction would be the function argument for the current function. This for a systemcall would be the address of the command string being called. In this case, this must be the address of the string "/bin/bash". There are several methods to locate this string in the executable using the 'strings' utility. On GUI debuggers such as the EDB this is trivial. Alternatively, one may store the string in an environment variable and point to the address of the environment variable to avoid locating the string.

Locating system call within the libc and having executable privileges is easy on EDB, and on GDB , one may simply do the following to find out the location of the systemcall as shown from within gdb. You may use other utilities such as mselfscan (a metasploit utility) or using the 'strings'utility. 

Note that the libc syscall takes only 1 argument which is the string address of the function being called. The stack6.py was used to generate the payload which was tested on the executable running on a 16.04 Ubuntu system.

|              ![rootwe-0.PNG](images/stack6.PNG)              |
| :----------------------------------------------------------: |
| Locating a syscall for performing ret2libc in the desired address range in EDB |

### Stack 7

This challenge again, reimposes a restriction on the blatant overriding of return address. Here we will employ a technique called "return to .text". If you look at the source code for this challenge , you will discover that the source code is very much similar. In stack6 the logic is checking for return address to not be in the stack range of the stackaddress and some of the code address which is the '\xbf' prefix. This was bypassed using the 'ret2libC' technique as the libC address was not in the restricted range. Usually, the libC technique is used for bypassing stack execution restriction, but here we have a restriction which prevents us from returning to libC

In stack7, the restricted address range for the EIP overrun, covers the libC region as well, thereby preventing the ret2libC exploit from working. Here we have to overwrite the EIP to point to something which controls the EIP via control of the stack. There are many variations and methods to accomplish this, the ultimate aim is to get execution without violating the address space check on EIP. We know that the EIP has to point to something which is not present in any address with prefix '0xb. Note, that here the stack is executable, so we can actually place our shellcode on the stack. To achieve this we must point to opcode strings which allow us to return execution to our shellcode. The basic idea would be to point to a 'RET' instruction and have our EIP point to this. We would have to place the address of our shellcode right adjacent to the stack so that the ret causes the address of the shellcode to be pushed onto EIP. But as we'd see, the shellcode address is restricted.



## Format String Vulnerabilities
These are set of challenges which require us to exploit the format string vulnerability. This is a class of vulnerability which exploits the format string which is an ascii string used to specify and control the representation of various variables. You can use it to read and write memory on the stack, thereby controlling the program execution. String formats such as "%d" and "%s" are used by functions like printf and sprintf to read/write memory on the stack. When passed as part of string input to vulnerable functions this can cause an outcome where the %s is treated as a format string to read the memory on the stack. "%n" is used to write to memory on the stack.
In the following set of challenges, we will achieve our exploit using the format string vulnerability, even when there are certain exploits where we can use the buffer overflow vulnerability.




### Format0

This one is the starting challenge and can be exploited both by an overflow and a format string exploit. The function code is provided below for reference, but we can do it without looking at this and just the disassembly as well.
If you look at the disassembly, you will see that a value is being compared with the EAX register , the very famous "deadbeef" string. If we can control the value stored in EAX, we can win this challenge, or if we can control the EIP to enter the instruction after the "JNE" instruction to avoid the branching altogether. We can accomplish this via a simple buffer overflow (at an offset of 64), but the challenge mentions that we need to do it < 10 bytes.

For the sanity check we can turn off ASLR, and achieve the outcome via buffer overflow as shown below. The pattern generated is 64 bytes long, and appended by "deadbeef" in reverse order.
```
./format0 $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A\xef\xbe\xad\xde'")
```

Let us achieve the outcome within the confines requested by this challenge. We can achieve the exploit by padding with a 64 bit format string and then appending the "deadbeef". So, the exploit can be of the following form.
```
./format0 $(python -c "print '%64d\xef\xbe\xad\xde'")
```
This would be the case where you would get a padding of 64 bytes. The content will be taken off the stack and padded with 64 bytes before outputting. The string containing %d is a format string. When we use it within say printf command *printf("%d",x)"*. It expects the first argument to be at *(ret addr+4 bytes)*, 2nd argument to be at *(ret address +8 bytes)*. printf you see, is a variadic function, i.e It can take multiple arguments. The function arguments are present outside the stackframe (lower in the stack, higher in memory than the return addr and EBP). For variadic functions in x86 architectures, the choice of calling functions is cdecl. 
There are different ways in which functions are called in x86 architectures which are present [here](https://devblogs.microsoft.com/oldnewthing/20040108-00/?p=41163). 

So how does the exploit work? With %64d we just told printf to read the next arg, and pad it with 64 bytes.

However this exploit does not work on a 64 bit modern system with ASLR enabled. See liveoverflow's video to see how to exploit and bypass this challenge on a modern system.



### Format1

For format1 we need to overwrite the target value. So far, we know that the format string vulnerability can be used to leak data off the stack. Even if stack is randomized, we can leak the stack information. For some challenges, we may be able to leak the stack canary and beat stack protection via memory leakage. For reading off the stack we can use certain characters like ("%d", %x) depending on how we format the data being read off the stack. However, in the man page of printf, we can see that there exists a format character called "%n", which can be used to read the value of the last written to variable.

"%n" in the man page is considered as a security flaw as well when dealing with untrusted user input. So what does "%n" do?
Consider the following code as stated in a stack overflow in an [answer](https://stackoverflow.com/questions/3401156/what-is-the-use-of-the-n-format-specifier-in-c) to the same question.
```C
#include <stdio.h>

int main()
{
  int val;

  printf("blah %n blah\n", &val);

  printf("val = %d\n", val);

  return 0;

}
```
The first printf has been passed the pointer (address) to the variable val. The first printf will not read any value, but write a value to the passed address. The value will be characters written so far in the printf statement. This value is 5, as there are 4 chars ('blah') plus 1 space written in the printf before '%n' is encountered. The second printf will print "val = 5".

Here our task is to overwrite the target variable to successfully pass this challenge, and hence we must make use of the "%n" command as stated above. We will have to write to the target variable on the stack. 


One more thing to note here, is that this won't work with ASLR enabled. With ASLR enabled, the stack only prints the address of the string on doing "%x" overflow, and not the actual string being stored on the stack.
Due to format string vulnerability we can print memory on the stack. When doing these challenges, always remember that our vulnerable function could be nested within functions, and be clear with the structure of the stack frame. The function arguments are outside the current function stack frame (higher than ebp of current stack frame, and below the local variables of the outer function, refer stack frame structure).

We can print out stack addresses by abusing the format string %x. We can supply the arguments to the executable and see that we can locate our string on the stack as shown in the image below. 


Now we need to overwrite the address of the target variable on the stack. We can see this variable by any debugger or by using objdump to see the offset. In absence of ASLR, we can know the exact location where this variable will be loaded into the memory as shown in the below (08049638)



Now, when we use %x, the printf prints the first entry which is the argument, every subsequent %x, printf prints the next (lower in stack, higher in memory).

Take an example of an argument like "AAAAA"+"%x" being passed onto the executable. What will it print? It will print the string. So it will print the A's. When it will encounter the "%x" it will ideally look for arguments being passed as it is a variadic function, format it as a hex string and print it. 

If we did multiple "%x", it will keep moving lower onto the stack(higher up in memory) to print the contents of the stack including addresses on the stack. If we do this enough times, we will eventually discover the string we are passing as argument . Why? Remember that the argument string is also stored in the stack, and we will eventually reach the string (our payload). This is an important finding. Remember that this will not work with ASLR enabled, as the string is then stored randomly and the address to it is stored on the stack ,not the string itself.

So we can print our payload if we supply a long enough string of "%x" (x is just the formatting, and controls the no of bytes read as well), but what can we do with it? What if we had an address as part of the string/payload? We could print it , sure. But let's bring into picture the "%n". If we say printed an address using the method we just discovered, and followed it with a %n and a value, we could write to it!


Then we need to have something like this "padding"+"address"+"%x*(number)"+"%n". The number being enough to get the %x to print our string on the stack,the padding and the address(the last value printed must be our target address), succeeded by %n. Now we need to replace the address with the address of our 'target' variable. This would result us in modifying the target variable, and successfully solve the challenge. The exploit payload for format 1 is as shown below.
```bash
./crackmes/format1 "`python -c 'print "AAAAAA"+"\x38\x96\x04\x08"+"BBB"+"%x"*168+"%n"'`"
```


### Format2


A step in the next direction, we need to not only control where we are writing with our payload, but also what we are writing. Like the challenges above, the ASLR has been disabled and the solution is shown for a 32 bit system. A later attempt would be made to solve these on a modern system or a x64 system. We can deduce the value of the target required by looking at the assembly code as shown in the image below. 1 shows the address where target is loaded from, and 2 shows that target is being compared against 0x40 which is 64 in decimal, and we need to successfully change the value of target to x40 to successfully clear this challenge.

We can do the *objdump -t ./crackmes/target2* to load the address offset for the target variable. Our input to the stack needs to be adjusted based on a lot of the factors. As we have seen in multiple exploits before, even the environment variables could throw us off our intended target. This is the main reason, exploit researchers are so fond of the NOP sled. From the image above, we know that the target variable is loaded onto the address "080496e4". 


Our inital part of crafting the exploit will be the same. We will need to insert the address of the target variable at a position which is after enough padding causing it to be the last thing to be printed off the stack or last argument to the variadic printf. So we know that if we use %n, and the address is the last argument, the no of characters printed so far will be written on to the target variable (refer the c program in the beginning part of format1). If we use the string below, we can see the address of the target variable as the last thing printed. Note that this time the executable takes arguments from stdin . If  we put a wrong or unreachable address , we would get a segmentation fault.


```bash
python -c "print 'AAAAAAAA'+'\xe4\x96\x04\x08'+'%x'*6" | ./crackmes/format2
```
If we write a %n, and remove one of the %x (to maintain the padding for us to be able to write to the same address), we notice that target variable has been modified but the value is changed to '47' as shown in the image below. That is the no of characters written so far when we used %n. 
```bash
python -c "print 'AAAAAAAA'+'\xe4\x96\x04\x08'+'%x'*5"+'%n' | ./crackmes/format2
```




So we need to write more characters to bring this value to 64. There is a catch here. We need to write to the target address, if we prefixed with more A's , the target address won't be the last thing printed from the stack. Our payload will shift and we might get a segmentation fault. %x is used to print the contents of the stack, so in order to maintain our padding and our correct address, any extra chars must be added after the %x and before %n. So, the correct payload is as shown below. This is because remember that with each %x or a format string, we are 'adding' an extra argument to printf, and moving our pointer to the lower areas of the stack. When we added a %n, we removed a %x , so that %n accesses the address instead of %x.
```bash
python -c "print 'AAAAAAAA'+'\xe4\x96\x04\x08'+'%x'*5+'a'*17+'%n'" | ./crackmes/format2
```


### Format3

We wrote 64 to our target variable in the last exploit. Could we write *any* value to our target variable then? In this challenge, we are required to exert more control on the value being written on the stack. We can write the 17 a's in another format possible. We can use the format character to give an extra padding to the exploit payload. If we go back to **format0**, we can see that we may use number for padding the characters we want. This brings us to an alternative way we could have solved the last challenge, by using padding character number. The alternate solution to challenge format2 is shown below.
```bash
python -c "print 'AAAAAAAA'+'\xe4\x96\x04\x08'+'%x'*4+'%25d'+'%n'" | ./crackmes/format2
```

In this challenge, we need to modify the target variable to a much larger value, as the disassembly shows. On doing objdump, we note that target variable is loaded at an address offset of "080496f4". From the disassembly, we know that the target value needs to be 0x01025544(in hex) for us to clear the challenge.


We craft our initial format string to calculate the padding and the no of format strings to reach our padded value of the address of target. When we do this, we would notice that the value of target changes to something. In my case, the value changed to 0x5b, implying we wrote the amount of chars so far onto target which is 5b, terribly shy of the intended value 0x1025544.
```bash
python -c "print 'AAAA'+'\xf4\x96\x04\x08'+'%x'*12+'%n'" | ./crackmes/format3
```

Now we need to write the amount of characters indicated by the difference of 0x01025544 and 0x5b. We could write a lot of A's , but we can make our payload shorter by the trick we used in Format0 and use the padding integer special char of %ad where a is the padding, and d is the integer format. The difference comes out to be 0x10254e9 which is 16930025 in decimal. Let's put it to the test with the exploit string below. I have piped  the output to remove the spaces or else you will get a large output on the screen (~16.9M chars!). The payload needed adjustment a bit more for the difference, about 8 to make for the characters to be written match the intended value of target. Note that we needed to take off one of the %x as we were using an extra format string "%d" to make %n still point to our intended address.

```bash
python -c "print 'AAAA'+'\xf4\x96\x04\x08'+'%x'*11+'%16930033d'+'%n'" | ./crackmes/format3 | tr -s " "
```




### Format4

We have not only written to our intended target so far, but we have established a way to control what we are writing to the variable as well. What we have not done, is control execution, so can we using a format string exploit control EIP? This is what is the objective of format4 challenge. Let us quickly use edb, to look at what the disassembly looks like:




We need to redirect output , so from the format string style of exploits we have been sticking to so far. So to achieve our goal, we must successfully rewrite the return address to the address of the instruction that prints the success message, which was deduced to be at an address offset of 080484ba. When overwriting the return address, we can do with return addresses of any of the outer function but not in this case. If you look at the disassembly, you will notice that the internal function that calls the vulnerable printf is followed by a exit syscall (shown by 1), and hence this will prevent the function from returning. In this scenario, we would have to overwrite the return address to the line where "printf" function is called. So, the printf function call on returning will redirect to our desired location, which is the hello function at the address **0x80484b4**.

If we go inside the printf function, we can see the return address location being stored on the stack, this is the address we must overwrite and must be part of our payload. However, there is a catch- Note that here we cannot be generous about our estimated overwrite of the return address as we do not have any NOPSLED at our disposal. It would be prudent to use the GOT here as a vector of attack. 


GOT or Global Offset Table is a method for executables to use shared library and reference the functions. The GOT section involves several "jmp" instructions , each one corresponding to the address of a function. It acts like a function trampoline. If you look at the image below, you can see the disassembly of the hello function , where we would want our redirected output to go.




